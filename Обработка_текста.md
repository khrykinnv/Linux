# Обработка текста

## Stdout and stderr
Концепции stdout и stderr в Linux относятся к основам обработки текста Linux. В Linux при выполнении программы обычно открываются три канала связи, а именно STDIN (стандартный ввод), STDOUT (стандартный вывод) и STDERR (стандартная ошибка).

Каждый из этих каналов имеет определенную функцию. STDOUT — это канал, по которому отправляется вывод большинства команд оболочки. STDERR, с другой стороны, используется специально для отправки сообщений об ошибках. Это различие очень полезно при написании скриптов или программировании, поскольку позволяет обрабатывать обычный вывод и сообщения об ошибках разными способами.

Вот пример фрагмента кода, показывающего, как используются эти каналы:
```commandline
$ command > stdout.txt 2>stderr.txt
```
В этом примере оператор ">" перенаправляет стандартный вывод (stdout) в текстовый файл с именем stdout.txt, а "2>" перенаправляет стандартный вывод ошибок (stderr) в stderr.txt. Таким образом, обычный вывод и сообщения об ошибках сохраняются отдельно в разных файлах для дальнейшего изучения или обработки.

## Cut
Команда cut используется, если нужно вырезать часть текста — при этом он может находиться в файле либо быть напечатанным через стандартный ввод. 

https://losst.pro/komanda-cut-linux

## Paste
используется для объединения строк из нескольких файлов
```commandline
paste file1.txt file2.txt > combined.txt
```
## Sort

```$ sort опции файл```

Или

```$ команда | sort опции```

```commandline
sort test.txt
```
* -b - не учитывать пробелы
* -d - использовать для сортировки только буквы и цифры
* -i - сортировать только по ASCII символах
* -n - сортировка строк linux по числовому значению
* -r - сортировать в обратном порядке
* -с - проверить был ли отсортирован файл
* -o - вывести результат в файл
* -u - игнорировать повторяющиеся строки
* -m - объединение ранее отсортированных файлов
* -k - указать поле по которому нужно сортировать строки, если не задано, сортировка выполняется по всей строке.
* -f - использовать в качестве разделителя полей ваш символ вместо пробела.

## tr
Используется для замены, замещения или удаления символов из стандартного ввода, отправляя результат на стандартный вывод.
```commandline
tr [КЛЮЧ]... НАБОР1 [НАБОР2]
```

| Ключ  |  Длинный вариант |  Значение |
|---|---|---|
|  -c, -C | --complement  |  Сначала получить дополнение НАБОРА1 |
| -d  | 	--delete  |  Удалить знаки из НАБОРА2, не превращать |
|  -s | --squeeze-repeats  |  Замещать последовательность знаков, которые повторяются, из перечисленных в последнем НАБОРЕ, на один такой знак |
| -t  |   --truncate-set1|   Сначала сократить НАБОР1 до размеров НАБОРА2|

Пример 1. Заменить все x на z.
```commandline
$ tr x z
```
https://losst.pro/komanda-tr-v-linux

## Head
Команда head выводит начальные строки (по умолчанию — 10)  из одного или нескольких документов. Также она может показывать данные, которые передает на вывод другая утилита.
```commandline
$ head опции файл
```
* -c (--bytes) — позволяет задавать количество текста не в строках, а в байтах. При записи в виде --bytes=[-]NUM выводит на экран все содержимое файла, кроме NUM байт, расположенных в конце документа.
* -n (--lines) — показывает заданное количество строк вместо 10, которые выводятся по умолчанию. Если записать эту опцию в виде --lines=[-]NUM, будет показан весь текст кроме последних NUM строк.
* -q (--quiet, --silent) — выводит только текст, не добавляя к нему название файла.
* -v (--verbose) — перед текстом выводит название файла.
* -z (--zero-terminated) — символы перехода на новую строку заменяет символами завершения строк.

## Tail
Позволяет выводить заданное количество строк с конца файла, а также выводить новые строки в интерактивном режиме.
```commandline
$ tail опции файл
```
* -c - выводить указанное количество байт с конца файла;
* -f - обновлять информацию по мере появления новых строк в файле;
* -n - выводить указанное количество строк из конца файла;
* --pid - используется с опцией -f, позволяет завершить работу утилиты, когда завершится указанный процесс;
* -q - не выводить имена файлов;
* --retry - повторять попытки открыть файл, если он недоступен;
* -v - выводить подробную информацию о файле;

Когда вы хотите отслеживать появление новых строк в файле, добавьте опцию -f:
```commandline
tail -f /var/log/syslog
```
## Join
Команда join выдает на стандартный вывод результат соединения двух отношений, задаваемых строками файла1 и файла2. Если вместо файла1 стоит -, то используется стандартный ввод.
```commandline
khrykinnv@s-779:~$ ls
1.txt  2.txt
khrykinnv@s-779:~$ cat 1.txt
1001 John Engineering
1002 Sarah Marketing
1003 Mike Sales
1004 Emily HR
1005 David Finance
khrykinnv@s-779:~$ cat 2.txt
1001 75000
1002 65000
1003 70000
1004 60000
1005 80000
khrykinnv@s-779:~$ join 1.txt 2.txt
1001 John Engineering 75000
1002 Sarah Marketing 65000
1003 Mike Sales 70000
1004 Emily HR 60000
1005 David Finance 80000
khrykinnv@s-779:~$
```
Разберем, что произошло:

1. Команда join проверила первое поле (идентификатор сотрудника) в обоих файлах.
2. Когда она нашла совпадающие идентификаторы, она объединила строки из обоих файлов.
3. Вывод показывает идентификатор сотрудника, за которым следуют все поля из файла 1.txt, а затем все поля из файла 2.txt (за исключением идентификатора, который был бы избыточным).

## Split
Данная команда разбивает один большой файл на несколько маленьких.
```commandline
$ split опции /местоположение/исходного/файла /путь/к/конечной/папке/префикс_имени
```
* -a, --suffix-length – задать длину суффикса (количество символов) в имени части файла. По умолчанию это 2 символа.
* --additional-suffix – указать дополнительный суффикс.
* -b, --bytes – разбить файл на части равного указанного размера. Единица измерения – 1 байт, 1000 байт записывается как KB, 1024 как K. По аналогии есть MB (M), GB (G) и так далее.
* -C, --line-bytes – разбить файл на части не более указанного размера, не разделяя строки/записи внутри него.
* -d – использовать числовой суффикс в имени конечного файла вместо алфавитного. Отсчет начинается с нуля.
* --numeric-suffixes – то же самое, что и -d, но еще задаётся начальное число для отсчета.
* -x – использовать hex-префикс вместо алфавитного. Начальное значение – 0.
* --hex-suffixes – то же самое, что и -x, но начальное значение задаётся вручную.
* -e, --elide-empty-files – не создавать пустые файлы при выполнении опции -n.
* -l, --lines – установить максимальное количество строк/записей итогового файла. По умолчанию команда split разбивает файл на 1000 строк.
* -n, --number – разбить файл на чанки (указанное количество частей).
* -t, --separator – установить свой разделительный символ вместо новой строки.
* --verbose – выводить информацию о новых файлах перед их созданием.
* --version – посмотреть версию утилиты.

https://losst.pro/kak-razbit-fajl-na-chasti-linux?liveurl=1

## Конвейер |
Конвейер (труба) в Linux — это способ соединения нескольких команд, когда вывод предыдущей служит вводом для следующей. Каждая команда в конвейере работает с полученными данными, выполняя определенные операции или преобразования.
```commandline
dmesg | head
```
## Tee
Иногда нам нужно сохранить вывод команды в файл, чтобы в последствии использовать вывод для других целей. Команда tee в Linux нужна для записи вывода любой команды в один или несколько файлов.
```commandline
$ tee опции файл
```
Опции команды:

* -a или -append - Используется для записи вывода в конец существующего файла.
*  -i или -ignore-interrupts - Используется, чтобы игнорировать прерывающие сигналы.
* -help - Используется для показа всех возможных операций.
* -version - Используется для показа текущей версии этой команды.

```commandline
ls -la | tee вывод.txt
```
## nl
Нумерация строк
```commandline
khrykinnv@s-779:~$ cat 1.txt
1001 John Engineering
1002 Sarah Marketing
1003 Mike Sales
1004 Emily HR
1005 David Finance
khrykinnv@s-779:~$ nl 1.txt
     1  1001 John Engineering
     2  1002 Sarah Marketing
     3  1003 Mike Sales
     4  1004 Emily HR
     5  1005 David Finance
khrykinnv@s-779:~$
```
Нумерация всех строк, включая пустые строки:
```commandline
khrykinnv@s-779:~$ nl -b a 1.txt
     1  1001 John Engineering
     2
     3
     4  1002 Sarah Marketing
     5  1003 Mike Sales
     6  1004 Emily HR
     7  1005 David Finance
khrykinnv@s-779:~$```
```
## grep
Фильтрация текста

Синтаксис команды выглядит следующим образом:

```commandline
$ grep [опции] шаблон [/путь/к/файлу/или/папке...]
```
Или:
```commandline
$ команда | grep [опции] шаблон
```
Здесь:

* Опции - это дополнительные параметры, с помощью которых указываются различные настройки поиска и вывода, например количество строк или режим инверсии.
* Шаблон - это любая строка или регулярное выражение, по которому будет выполняться поиск.
* Имя файла или папки - это то место, где будет выполняться поиск. Как вы увидите дальше, grep позволяет искать в нескольких файлах и даже в каталоге, используя рекурсивный режим.

Опции:
* -E, --extended-regexp - включить расширенный режим регулярных выражений (ERE);
* -F, --fixed-strings - рассматривать шаблон поиска как обычную строку, а не регулярное выражение;
* -G, --basic-regexp - интерпретировать шаблон поиска как базовое регулярное выражение (BRE);
* -P, --perl-regexp - рассматривать шаблон поиска как регулярное выражение Perl;
* -e, --regexp - альтернативный способ указать шаблон поиска, опцию можно использовать несколько раз, что позволяет указать несколько шаблонов для поиска файлов, содержащих один из них;
* -f, --file - читать шаблон поиска из файла;
* -i, --ignore-case - не учитывать регистр символов;
* -v, --invert-match - вывести только те строки, в которых шаблон поиска не найден;
* -w, --word-regexp - искать шаблон как слово, отделенное пробелами или другими знаками препинания;
* -x, --line-regexp - искать шаблон как целую строку, от начала и до символа перевода строки;
* -c - вывести количество найденных строк;
* --color - включить цветной режим, доступные значения: never, always и auto;
* -L, --files-without-match - выводить только имена файлов, будут выведены все файлы в которых выполняется поиск;
* -l, --files-with-match - аналогично предыдущему, но будут выведены только файлы, в которых есть хотя бы одно вхождение;
* -m, --max-count - остановить поиск после того как будет найдено указанное количество строк;
* -o, --only-matching - отображать только совпавшую часть, вместо отображения всей строки;
* -h, --no-filename - не выводить имя файла;
* -q, --quiet - не выводить ничего;
* -s, --no-messages - не выводить ошибки чтения файлов;
* -A, --after-content - показать вхождение и n строк после него;
* -B, --before-content - показать вхождение и n строк перед ним;
* -C - показать n строк до и после вхождения;
* -a, --text - обрабатывать двоичные файлы как текст;
* --exclude - пропустить файлы имена которых соответствуют регулярному выражению;
* --exclude-dir - пропустить все файлы в указанной директории;
* -I - пропускать двоичные файлы;
* --include - искать только в файлах, имена которых соответствуют регулярному выражению;
* -r - рекурсивный поиск по всем подпапкам;
* -R - рекурсивный поиск включая ссылки;

## awk
Фильтрация текста
```commandline
$ awk опции 'условие {действие}'

$ awk опции 'условие {действие} условие {действие}'
```
С помощью действия можно выполнять преобразования с обрабатываемой строкой. Об этом мы поговорим позже, а сейчас давайте рассмотрим опции утилиты:

* -F, --field-separator - разделитель полей, используется для разбиения текста на колонки;
* -f, --file - прочитать данные не из стандартного вывода, а из файла;
* -v, --assign - присвоить значение переменной, например foo=bar;
* -b, --characters-as-bytes - считать все символы однобайтовыми;
* -d, --dump-variables - вывести значения всех переменных awk по умолчанию;
* -D, --debug - режим отладки, позволяет вводить команды интерактивно с клавиатуры;
* -e, --source - выполнить указанный код на языке awk;
* -o, --pretty-print - вывести результат работы программы в файл;
* -V, --version - вывести версию утилиты.

Это далеко не все опции awk, однако их вам будет достаточно на первое время. Теперь перечислим несколько функций-действий, которые вы можете использовать:

* print(строка) - вывод чего либо в стандартный поток вывода;
* printf(строка) - форматированный вывод в стандартный поток вывода;
* system(команда) - выполняет команду в системе;
* length(строка) - возвращает длину строки;
* substr(строка, старт, количество) - обрезает строку и возвращает результат;
* tolower(строка) - переводит строку в нижний регистр;
* toupper(строка) - переводить строку в верхний регистр.
Функций намного больше, но чтобы не загромождать статью я привел только те, которые мы будем использовать сегодня, а также ещё несколько для чтобы вы могли оценить масштаб возможностей утилиты.

В функциях-действиях можно использовать различные переменные и операторы, вот несколько из них:

* FNR - номер обрабатываемой строки в файле;
* FS - разделитель полей;
* NF - количество колонок в данной строке;
* NR - общее количество строк в обрабатываемом тексте;
* RS - разделитель строк, по умолчанию символ новой строки;
* $ - ссылка на колонку по номеру.

Кроме этих переменных, есть и другие, а также можно объявлять свои.

Условие позволяет обрабатывать только те строки, в которых содержатся нужные нам данные, его можно использовать в качестве фильтра, как grep. А ещё условие позволяет выполнять определенные блоки кода awk для начала и конца файла, для этого вместо регулярного выражения используйте директивы BEGIN (начало) и END (конец). Там ещё есть очень много всего, но на сегодня пожалуй достаточно. Теперь давайте перейдем к примерам.
